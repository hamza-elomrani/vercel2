<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kitchen 3D Model</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="container"></div>
  
  <button class="toggle-btn" onclick="toggleControls()">Menu</button>
  
  <div id="controls">
    <h3>Kitchen Controls</h3>
    
    <div class="control-group">
      <label>Camera Views:</label>
      <button onclick="setView('perspective')" id="btn-perspective" class="active">3D View</button>
      <button onclick="setView('front')" id="btn-front">Front</button>
      <button onclick="setView('top')" id="btn-top">Top</button>
      <button onclick="setView('side')" id="btn-side">Side</button>
    </div>
    
    <div class="control-group">
      <label>Wall Color:</label>
      <input type="color" id="wallColor" value="#f5f5dc" onchange="changeWallColor(this.value)">
    </div>
    
    <div class="control-group">
      <label>Cabinet Color:</label>
      <input type="color" id="cabinetColor" value="#8b4513" onchange="changeCabinetColor(this.value)">
    </div>
    
    <div class="control-group">
      <label>Counter Color:</label>
      <input type="color" id="counterColor" value="#2f4f4f" onchange="changeCounterColor(this.value)">
    </div>
    
    <div class="control-group">
      <label>Floor Color:</label>
      <input type="color" id="floorColor" value="#d4b896" onchange="changeFloorColor(this.value)">
    </div>
    
    <div class="control-group">
      <label>Lighting: <span id="lightValue">0.8</span></label>
      <input type="range" min="0.3" max="2" step="0.1" value="0.8" onchange="changeLighting(this.value)">
    </div>
    
    <div class="control-group">
      <button onclick="toggleRotation()" id="rotateBtn">Pause Rotation</button>
      <button onclick="resetCamera()">Reset View</button>
    </div>
  </div>
  
  <div id="info">
    <strong>Kitchen Dimensions:</strong><br>
    Width: 4.20m<br>
    Depth: 2.72m<br>
    Counter: 2.8m<br><br>
    <strong>Mouse Controls:</strong><br>
    Left Drag: Rotate<br>
    Scroll: Zoom
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="kitchen.js"></script>
</body>
</html> -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive 3D Kitchen (no roof)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0}
    #canvas{width:100%;height:100%;display:block}
    .label{font-family:Arial,Helvetica,sans-serif;padding:2px 6px;border-radius:4px;background:rgba(255,255,255,0.9);border:1px solid #333}
    #ui{position:fixed;left:12px;top:12px;z-index:10;background:rgba(255,255,255,0.9);padding:8px;border-radius:6px}
    a{color:#06f}
  </style>
</head>
<body>
  <div id="ui">
    <strong>Kitchen 3D</strong><br>
    Controls: drag to rotate, scroll to zoom, right-drag to pan.<br>
    <label><input id="toggleLabels" type="checkbox" checked> Show dimensions</label>
    <br>
    <small>Floor plan reference image is used for placement.</small>
  </div>
  <canvas id="canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/renderers/CSS2DRenderer.js"></script>

  <script>
  // Using meters -> scene units (1 m = 1 unit). You can change scale by multiplying.
  const SCALE = 1.0; // 1 unit == 1 meter

  // Reference image path (your uploaded file) - developer provided local path
  const REF_IMAGE = '/mnt/data/f4f7defb-6e97-4eec-94f7-efbc5b6c2ca6.png';

  // Room geometry parameters (best-effort approximation from the plan):
  const dims = {
    topWidth: 4.20,
    leftHeight: 2.72,
    bottomSegA: 2.47,
    bottomSegB: 1.20,
    bottomSegC: 3.57,
    doorGap: 0.20, // 20 cm
    shelfGap: 0.10 // 10 cm
  };

  // Construct polygon for floor (clockwise)
  // We'll place bottom-left at (0,0). Bottom runs left->right with total 7.24 m.
  const bottomTotal = dims.bottomSegA + dims.bottomSegB + dims.bottomSegC; // 7.24
  // Place topWidth centered above the bottom with an offset to make trapezoid
  const topXStart = 1.5; // chosen offset in meters (best effort)
  const topXEnd = topXStart + dims.topWidth;

  const floorPoints = [
    new THREE.Vector2(0, 0), // bottom-left
    new THREE.Vector2(bottomTotal, 0), // bottom-right
    // right slanted corner up to top line (make a slanted right wall to match diagram)
    new THREE.Vector2(topXEnd + 0.6, dims.leftHeight),
    new THREE.Vector2(topXStart, dims.leftHeight),
  ];

  // Scene setup
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf2f2f2);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(bottomTotal/2, 6, bottomTotal); // good initial view

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  hemi.position.set(0,20,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(-10,20,10);
  scene.add(dir);

  // Floor shape (extrude slightly down so walls sit on top)
  const shape = new THREE.Shape(floorPoints);
  const extrudeSettings = {depth:0.01, bevelEnabled:false};
  const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  const mat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.8});
  const floor = new THREE.Mesh(geom, mat);
  floor.rotateX(-Math.PI/2);
  floor.position.y = 0;
  floor.receiveShadow = true;
  scene.add(floor);

  // Reference image removed â€“ using pure simulated layout

    const refPlane = new THREE.Mesh(planeGeom, planeMat);
    refPlane.rotation.x = -Math.PI/2;
    // center plane above the floor
    const centerX = bottomTotal/2;
    const centerZ = (0 + dims.leftHeight)/2; // since floor points define top at y = leftHeight
    refPlane.position.set(centerX, 0.01, centerZ);
    scene.add(refPlane);
  });

  // Create walls by extruding the floor polygon upward; we will omit the roof
  function makeWalls(points2D, height){
    const wallGroup = new THREE.Group();
    for(let i=0;i<points2D.length;i++){
      const a = points2D[i];
      const b = points2D[(i+1)%points2D.length];
      // build a thin box between a and b
      const dx = b.x - a.x;
      const dz = b.y - a.y; // note: floorPoints used as (x,z) in 3D
      const length = Math.sqrt(dx*dx + dz*dz);
      const angle = Math.atan2(dz, dx);
      const wallGeom = new THREE.BoxGeometry(length, height, 0.12); // 12 cm wall thickness
      const wallMat = new THREE.MeshStandardMaterial({color:0x333333});
      const wall = new THREE.Mesh(wallGeom, wallMat);
      // position wall: center of segment
      const cx = a.x + dx/2;
      const cz = a.y + dz/2;
      wall.position.set(cx, height/2, cz);
      wall.rotation.y = -angle;
      wallGroup.add(wall);
    }
    return wallGroup;
  }

  const wallHeight = 2.5; // meters
  const walls = makeWalls(floorPoints, wallHeight);
  scene.add(walls);

  // Example furniture placement (range cooker, fridge, sink, planter) using boxes sized in meters
  const furnGroup = new THREE.Group();
  function addBox(x,z,w,d,h,color,label){
    const g = new THREE.BoxGeometry(w, h, d);
    const m = new THREE.MeshStandardMaterial({color:color||0x8b7f70});
    const box = new THREE.Mesh(g,m);
    box.position.set(x + w/2, h/2, z + d/2);
    furnGroup.add(box);
    if(label) addLabel(label, x + w/2, h + 0.05, z + d/2);
  }

  // Place fridge and cooker at bottom-left corner (approx)
  addBox(0.1, 0.1, 0.6, 0.6, 0.9, 0x7e6f5a, 'Range Cooker');
  addBox(0.75, 0.1, 0.6, 0.6, 1.8, 0x7f7467, 'Fridge');
  // sink under window center - approximate: place at bottomSegA + bottomSegB/2 - to align with diagram
  const sinkX = dims.bottomSegA + dims.bottomSegB/2 - 0.3; // center-ish
  addBox(sinkX, 0.4, 0.8, 0.6, 0.9, 0x8f7f6f, 'Kitchen sink');
  // potager near door at right side
  const potX = bottomTotal - 0.8;
  addBox(potX, 0.8, 0.6, 0.6, 0.6, 0x7a6d5a, 'Potager');

  scene.add(furnGroup);

  // Labels: using CSS2DRenderer
  const labelRenderer = new THREE.CSS2DRenderer();
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0px';
  document.body.appendChild(labelRenderer.domElement);

  function createLabelElement(text){
    const div = document.createElement('div');
    div.className = 'label';
    div.textContent = text;
    return div;
  }

  const labels = [];
  function addLabel(text, x, y, z){
    const el = createLabelElement(text);
    const label = new THREE.CSS2DObject(el);
    label.position.set(x, y, z);
    scene.add(label);
    labels.push(label);
    return label;
  }

  // Add dimension lines and labels (main distances)
  function addDimensionLine(x1,z1,x2,z2, text){
    // line
    const pts = [new THREE.Vector3(x1, 0.02, z1), new THREE.Vector3(x2, 0.02, z2)];
    const geomL = new THREE.BufferGeometry().setFromPoints(pts);
    const matL = new THREE.LineBasicMaterial({color:0x0066cc});
    const line = new THREE.Line(geomL, matL);
    scene.add(line);
    // label at midpoint
    const mx = (x1 + x2)/2;
    const mz = (z1 + z2)/2;
    addLabel(text, mx, 0.05, mz);
  }

  // bottom segments
  addDimensionLine(0,0, dims.bottomSegA,0, dims.bottomSegA.toFixed(2)+' m');
  addDimensionLine(dims.bottomSegA,0, dims.bottomSegA + dims.bottomSegB,0, dims.bottomSegB.toFixed(2)+' m');
  addDimensionLine(dims.bottomSegA + dims.bottomSegB,0, bottomTotal,0, dims.bottomSegC.toFixed(2)+' m');
  // top width
  addDimensionLine(topXStart, dims.leftHeight, topXEnd, dims.leftHeight, dims.topWidth.toFixed(2)+' m');
  // left height
  addDimensionLine(0,0, 0, dims.leftHeight, dims.leftHeight.toFixed(2)+' m');
  // door gap (approx: place near right wall)
  const doorX = bottomTotal - 0.5; // chosen spot
  addDimensionLine(doorX, 0.02, doorX + dims.doorGap, 0.02, (dims.doorGap*100).toFixed(0)+' cm');
  // shelf gap at top
  addDimensionLine(topXEnd - 0.12, dims.leftHeight - 0.05, topXEnd - 0.12, dims.leftHeight - 0.15, (dims.shelfGap*100).toFixed(0)+' cm');

  // Camera controls
  const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
  controls.target.set(bottomTotal/2, 0.8, dims.leftHeight/2);
  controls.update();

  // toggle labels
  document.getElementById('toggleLabels').addEventListener('change', e => {
    labels.forEach(l => { l.element.style.display = e.target.checked ? '' : 'none'; });
  });

  // render loop
  function resize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', resize);

  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  animate();

  // Helpful console info
  console.log('Kitchen 3D loaded. Room approx dimensions (meters):', dims);
  </script>
</body>
</html>
